/* FILE: src/server/services/QueueService.ts */
import { Transaction } from 'sequelize';
import { sequelize } from '../db';
import { TicketRepository } from '../repositories/TicketRepository';
import { EventRepository } from '../repositories/EventRepository';
import { CounterRepository } from '../repositories/CounterRepository';
import { Ticket, TicketStatus } from '../models/ticket.model';
import { EventType } from '../models/ticket_event.model';

export interface IssueTicketRequest {
  locationId: number;
  counterId: number;
  userId?: number;
  dateFor?: string;
}

export interface CallNextResponse {
  ticket: Ticket | null;
  queueNumber?: string;
  message: string;
}

export class QueueService {
  private ticketRepository: TicketRepository;
  private eventRepository: EventRepository;
  private counterRepository: CounterRepository;

  constructor() {
    this.ticketRepository = new TicketRepository();
    this.eventRepository = new EventRepository();
    this.counterRepository = new CounterRepository();
  }

  /**
   * Issue a new ticket with transactional safety
   */
  async issue(request: IssueTicketRequest): Promise<Ticket> {
    return sequelize.transaction({ 
      isolationLevel: Transaction.ISOLATION_LEVELS.REPEATABLE_READ 
    }, async (t) => {
      const { locationId, counterId, userId, dateFor } = request;
      const today = dateFor || new Date().toISOString().split('T')[0];

      // Validate counter exists and is active
      const counter = await this.counterRepository.findById(counterId, t);
      if (!counter || !counter.is_active) {
        throw new Error('Counter not found or inactive');
      }

      // Check capacity
      const capacityStatus = await this.counterRepository.getCapacityStatus(counterId, today, t);
      if (capacityStatus.isAtCapacity) {
        throw new Error('Counter has reached daily capacity');
      }

      // Create ticket with automatic sequence generation
      const ticket = await this.ticketRepository.createTicket({
        location_id: locationId,
        counter_id: counterId,
        user_id: userId,
        date_for: today,
        status: TicketStatus.WAITING,
        sequence: 0, // Will be overwritten by createTicket
        queue_number: '', // Will be generated by createTicket
      }, t);

      // Create ISSUED event
      await this.eventRepository.create({
        ticket_id: ticket.id,
        actor_id: userId,
        event_type: EventType.ISSUED,
        note: `Ticket issued for ${counter.name}`,
      }, t);

      return ticket;
    });
  }

  /**
   * Call next waiting ticket with row locking to prevent race conditions
   */
  async callNext(counterId: number, actorId: number): Promise<CallNextResponse> {
    return sequelize.transaction({ 
      isolationLevel: Transaction.ISOLATION_LEVELS.REPEATABLE_READ 
    }, async (t) => {
      // Find next waiting ticket with row lock
      const nextTicket = await this.ticketRepository.getNextWaitingTicket(counterId, t);
      
      if (!nextTicket) {
        return {
          ticket: null,
          message: 'No tickets waiting in queue',
        };
      }

      const now = new Date();
      
      // Update ticket status to CALLING
      await this.ticketRepository.updateStatus(
        nextTicket.id,
        TicketStatus.CALLING,
        { 
          called_at: now,
          started_at: now,
        },
        t
      );

      // Create CALLED event
      await this.eventRepository.create({
        ticket_id: nextTicket.id,
        actor_id: actorId,
        event_type: EventType.CALLED,
        note: 'Ticket called by staff',
      }, t);

      // Refetch ticket with updated data
      const updatedTicket = await this.ticketRepository.findById(nextTicket.id, t);

      return {
        ticket: updatedTicket,
        queueNumber: nextTicket.queue_number,
        message: `Called ticket ${nextTicket.queue_number}`,
      };
    });
  }

  /**
   * Hold a ticket with reason
   */
  async hold(ticketId: number, reason: string, actorId: number): Promise<Ticket> {
    return sequelize.transaction({ 
      isolationLevel: Transaction.ISOLATION_LEVELS.READ_COMMITTED 
    }, async (t) => {
      const ticket = await this.ticketRepository.findById(ticketId, t);
      
      if (!ticket) {
        throw new Error('Ticket not found');
      }

      if (![TicketStatus.CALLING, TicketStatus.SERVING].includes(ticket.status)) {
        throw new Error('Can only hold tickets that are being called or served');
      }

      // Update ticket status
      await this.ticketRepository.updateStatus(
        ticketId,
        TicketStatus.HOLD,
        { hold_reason: reason },
        t
      );

      // Create HELD event
      await this.eventRepository.create({
        ticket_id: ticketId,
        actor_id: actorId,
        event_type: EventType.HELD,
        note: reason,
      }, t);

      return this.ticketRepository.findById(ticketId, t) as Promise<Ticket>;
    });
  }

  /**
   * Resume a held ticket
   */
  async resume(ticketId: number, actorId: number): Promise<Ticket> {
    return sequelize.transaction({ 
      isolationLevel: Transaction.ISOLATION_LEVELS.READ_COMMITTED 
    }, async (t) => {
      const ticket = await this.ticketRepository.findById(ticketId, t);
      
      if (!ticket) {
        throw new Error('Ticket not found');
      }

      if (ticket.status !== TicketStatus.HOLD) {
        throw new Error('Can only resume tickets that are on hold');
      }

      // Update ticket status back to WAITING
      await this.ticketRepository.updateStatus(
        ticketId,
        TicketStatus.WAITING,
        { 
          hold_reason: undefined,
          called_at: undefined,
          started_at: undefined,
        },
        t
      );

      // Create RESUMED event
      await this.eventRepository.create({
        ticket_id: ticketId,
        actor_id: actorId,
        event_type: EventType.RESUMED,
        note: 'Ticket resumed and returned to queue',
      }, t);

      return this.ticketRepository.findById(ticketId, t) as Promise<Ticket>;
    });
  }

  /**
   * Mark ticket as done/completed
   */
  async done(ticketId: number, actorId: number): Promise<Ticket> {
    return sequelize.transaction({ 
      isolationLevel: Transaction.ISOLATION_LEVELS.READ_COMMITTED 
    }, async (t) => {
      const ticket = await this.ticketRepository.findById(ticketId, t);
      
      if (!ticket) {
        throw new Error('Ticket not found');
      }

      if (![TicketStatus.CALLING, TicketStatus.SERVING].includes(ticket.status)) {
        throw new Error('Can only complete tickets that are being served');
      }

      const finishedAt = new Date();
      
      // Update ticket status
      await this.ticketRepository.updateStatus(
        ticketId,
        TicketStatus.DONE,
        { finished_at: finishedAt },
        t
      );

      // Create DONE event
      await this.eventRepository.create({
        ticket_id: ticketId,
        actor_id: actorId,
        event_type: EventType.DONE,
        note: 'Service completed',
      }, t);

      return this.ticketRepository.findById(ticketId, t) as Promise<Ticket>;
    });
  }

  /**
   * Cancel a ticket
   */
  async cancel(ticketId: number, reason: string, actorId?: number): Promise<Ticket> {
    return sequelize.transaction({ 
      isolationLevel: Transaction.ISOLATION_LEVELS.READ_COMMITTED 
    }, async (t) => {
      const ticket = await this.ticketRepository.findById(ticketId, t);
      
      if (!ticket) {
        throw new Error('Ticket not found');
      }

      if ([TicketStatus.DONE, TicketStatus.CANCELLED].includes(ticket.status)) {
        throw new Error('Cannot cancel completed or already cancelled tickets');
      }

      // Update ticket status
      await this.ticketRepository.updateStatus(
        ticketId,
        TicketStatus.CANCELLED,
        { hold_reason: reason },
        t
      );

      // Create CANCELLED event
      await this.eventRepository.create({
        ticket_id: ticketId,
        actor_id: actorId,
        event_type: EventType.CANCELLED,
        note: reason,
      }, t);

      return this.ticketRepository.findById(ticketId, t) as Promise<Ticket>;
    });
  }

  /**
   * Get queue status for a counter
   */
  async getQueueStatus(counterId: number, date?: string) {
    const today = date || new Date().toISOString().split('T')[0];
    return this.ticketRepository.getQueueStatus(counterId, today);
  }

  /**
   * Get all tickets for today at a location
   */
  async getTodayTickets(locationId: number, date?: string, page: number = 1, limit: number = 50) {
    const today = date || new Date().toISOString().split('T')[0];
    const offset = (page - 1) * limit;
    return this.ticketRepository.listToday(locationId, today, offset, limit);
  }

  /**
   * Find ticket by queue number
   */
  async findTicketByQueueNumber(queueNumber: string) {
    return this.ticketRepository.findByQueueNumber(queueNumber);
  }

  /**
   * Get user's tickets for today
   */
  async getUserTickets(userId: number, date?: string) {
    const today = date || new Date().toISOString().split('T')[0];
    return this.ticketRepository.findUserTickets(userId, today);
  }

  /**
   * Get estimated wait time for a ticket
   */
  async getEstimatedWaitTime(ticketId: number) {
    const ticket = await this.ticketRepository.findById(ticketId);
    if (!ticket) {
      throw new Error('Ticket not found');
    }

    return this.ticketRepository.getEstimatedWaitTime(
      ticket.counter_id,
      ticket.sequence,
      ticket.date_for
    );
  }

  /**
   * Start serving a ticket (transition from CALLING to SERVING)
   */
  async startServing(ticketId: number, _actorId: number): Promise<Ticket> {
    return sequelize.transaction({ 
      isolationLevel: Transaction.ISOLATION_LEVELS.READ_COMMITTED 
    }, async (t) => {
      const ticket = await this.ticketRepository.findById(ticketId, t);
      
      if (!ticket) {
        throw new Error('Ticket not found');
      }

      if (ticket.status !== TicketStatus.CALLING) {
        throw new Error('Can only start serving tickets that are being called');
      }

      // Update ticket status to SERVING
      await this.ticketRepository.updateStatus(
        ticketId,
        TicketStatus.SERVING,
        { started_at: new Date() },
        t
      );

      // Note: No event created for this transition as it's internal status change

      return this.ticketRepository.findById(ticketId, t) as Promise<Ticket>;
    });
  }
}